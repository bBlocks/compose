<!DOCTYPE html>
<html>
<head>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.css"/>
	<style>
		.markdown-body {
			box-sizing: border-box;
			min-width: 200px;
			max-width: 980px;
			margin: 0 auto;
			padding: 45px;
		}

		@media (max-width: 767px) {
			.markdown-body {
				padding: 15px;
			}
		}
	</style>
	<script src="../compose.umd.js"></script>
</head>
<body>
<article class="markdown-body">
<h1 id="discover-super-powers-of-composition-and-inheritance-in-javascript-with-compose-library">Discover super powers of composition and inheritance in javascript with compose library</h1>
<p><a href="#quick-start">Quick start</a>
<a href="#discover-super-powers-of-composition-and-inheritance-in-javascript-with-compose-library">Solving: Composition of object with property descriptors</a></p>
<h2 id="quick-start">Quick start</h2>
<p>install</p>
<pre><code class="lang-nmp">npm install @bblocks/compose --save-dev
</code></pre>
<p>include</p>
<pre><code class="lang-html">&lt;!-- include the library --&gt;
&lt;script src=&quot;../compose.umd.js&quot;&gt;&lt;/script&gt;
</code></pre>
<pre><code class="lang-javascript">// Optionally create shortcuts in lodash style 
var _ = _ || {};
_.inherit = compose.inherit; 
_.compose = compose.compose; 
_.Block = compose.Block;
_.block = compose.block;
</code></pre>
<p>enjoy</p>
<pre><code class="lang-javascript">
// Composition
_.compose({prop1: 1}, {prop2: 2});

// Inheritance
_.inherit({prop1: 1}, {prop2: 2}, {foo: function() {}});

// Handy object with built-in features to compose, clone and define properties
let myObj = new _.Block({prop1:1}); // Our building block
let myClone = myObj
    .mix({prop2:2}) 
    .define({
        prop3: {
            get: function() {return 3},
        }
    })
    .clone({prop4: 4});

// Check results we created
console.log(myClone.__proto__, myClone.prop1, myClone.prop2, myClone.prop3, myClone.prop4); // {...} 1 2 3 4
</code></pre>
<h2 id="since-es5-object-in-javascript-became-more-powerful-thanks-to-property-descriptors-">Since ES5 Object in javascript became more powerful. Thanks to property descriptors.</h2>
<p>In the first example we create and object that can display numbers with suffixes like 1M, 1k, 1b etc...</p>
<pre><code class="lang-javascript">// Display big numbers with suffixes
let bigNumber = {
    suffixes: [&quot;&quot;, &quot;k&quot;, &quot;m&quot;, &quot;b&quot;,&quot;t&quot;],
    toString: function (value) {
        var newValue = value;
        if (value &gt;= 1000) {
            var suffixes = this.suffixes;
            var suffixNum = Math.floor( (&quot;&quot;+value).length/3 );
            var shortValue = &#39;&#39;;
            for (var precision = 2; precision &gt;= 1; precision--) {
                shortValue = parseFloat( (suffixNum != 0 ? (value / Math.pow(1000,suffixNum) ) : value).toPrecision(precision));
                var dotLessShortValue = (shortValue + &#39;&#39;).replace(/[^a-zA-Z 0-9]+/g,&#39;&#39;);
                if (dotLessShortValue.length &lt;= 2) { break; }
            }
            if (shortValue % 1 != 0)  shortNum = shortValue.toFixed(1);
            newValue = shortValue+suffixes[suffixNum];
        }
        return newValue;
    }
};
console.log(&#39;100000 = &#39; + bigNumber.toString(100000)); // 1000000 = 1m 
</code></pre>
<pre><code class="lang-javascript">// We can automatically generate a short string when value changes thanks to getters and setters 
Object.defineProperty(bigNumber, &#39;value&#39;, {
    get: function() {
        return this._value || 0;
    },
    set: function(newValue) {
        if (newValue != this._value) {
            this.stringValue = this.toString(newValue);
        }
        this._value = newValue;
    }
});
// Create a new instance
let myNumber = Object.create(bigNumber);
myNumber.value = 1000;
console.log(myNumber.value + &#39; = &#39; + myNumber.stringValue); // 1000 = 1k
</code></pre>
<h2 id="i-discovered-a-problem-that-we-loose-all-properties-descriptors-when-we-try-to-compose-two-objects-">I discovered a problem that we loose all properties descriptors when we try to compose two objects.</h2>
<pre><code class="lang-javascript">//  Define a new feature to increment a number
let increment = {
    increment: function() {
        this.value = (this.value || 0) + 1;
    }
}

// Compose increment and big number features  
let incNumber = Object.create(increment);
Object.assign(incNumber, bigNumber);

incNumber.increment(); // value = 1;

console.log(incNumber.value); // 1
console.log(incNumber.stringValue); // undefined :(
</code></pre>
<p>So we lost all the magic after composition. Solution to this problem looks bulky.</p>
<pre><code class="lang-javascript">Object.defineProperties(incNumber, Object.getOwnPropertyDescriptors(bigNumber));
incNumber.increment(); // value = 1;
console.log(incNumber.stringValue); // 1  Yes!!!
</code></pre>
<p>But we still have a problem because Object.assign and Object.getOwnPropertyDescriptors are not supported in IE11. Oh no ;(</p>
<p>// Re-define our mixed object
let myIncNumber = _.inherit(increment);
_.compose(myIncNumber, bigNumber);
// or
let myIncNumber2 = _.inherit(increment, bigNumber);</p>
<p>myIncNumber.increment();
myIncNumber2.value = 1000;
console.log(myIncNumber.stringValue, myIncNumber2.stringValue); // 1, 1k
<code>`</code></p>
</article>
<script src="demo.js"></script>
</body>
</html>